import os
import signal
import sys
import logging
from dotenv import load_dotenv

load_dotenv()

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles

from routers import applications, cameras, violations, streams, video_feed, detections
from streaming import STREAM_ROOT, stream_manager
from fastapi import WebSocket
from websocket_manager import manager

logger = logging.getLogger(__name__)

app = FastAPI(title="CCTV Analytics Platform")

# Signal handler for graceful shutdown
def signal_handler(sig, frame):
    """Handle Ctrl+C gracefully"""
    logger.info("Shutdown signal received, cleaning up...")
    # Stop streams
    stream_manager.stop_all()
    # Stop video feed processor
    from routers.video_feed import processor, processor_lock
    with processor_lock:
        if processor is not None:
            logger.info("Stopping video feed processor...")
            processor.stop()
    sys.exit(0)

# Register signal handlers
signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

# Register WebSocket endpoint BEFORE CORS middleware to avoid interference
@app.websocket("/ws/violations")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket endpoint for real-time violation/detection updates"""
    try:
        await manager.connect(websocket)
        try:
            while True:
                await websocket.receive_text()
        except Exception:
            pass  # Client disconnected or error occurred
        finally:
            manager.disconnect(websocket)
    except Exception as e:
        # Connection failed during handshake
        logger.error(f"WebSocket connection failed: {e}")
        try:
            await websocket.close()
        except Exception:
            pass

# Allow the frontend (Vite dev server) plus any comma-separated origins set in CORS_ORIGINS
origins_env = os.getenv(
    "CORS_ORIGINS",
    "http://localhost:5173,http://127.0.0.1:5173,http://127.0.0.1:60001,http://localhost:3000",
)
origins = [origin.strip() for origin in origins_env.split(",") if origin.strip()]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(applications.router)
app.include_router(cameras.router)
app.include_router(violations.router)
app.include_router(streams.router)
app.include_router(video_feed.router)
app.include_router(detections.router)

# Serve HLS playlists/segments generated by ffmpeg
STREAM_ROOT.mkdir(exist_ok=True)
app.mount("/streams", StaticFiles(directory=STREAM_ROOT, check_dir=False), name="streams")


@app.get("/")
async def root():
    return {"message": "CCTV Backend is running"}


@app.get("/health")
async def health_check():
    return {"status": "ok"}

@app.get("/test-ws-route")
async def test_ws_route():
    """Test endpoint to verify WebSocket route is registered"""
    ws_routes = [r for r in app.routes if hasattr(r, 'path') and '/ws' in r.path]
    return {
        "message": "Backend is accessible", 
        "ws_endpoint": "/ws/violations",
        "ws_route_registered": len(ws_routes) > 0,
        "ws_routes": [{"path": r.path, "name": getattr(r, 'name', 'unknown')} for r in ws_routes]
    }

@app.get("/test-ws")
async def test_ws():
    """Test endpoint to verify backend is accessible"""
    return {"message": "Backend is accessible", "ws_endpoint": "/ws/violations"}


@app.on_event("startup")
async def startup_event():
    from database import engine
    from models import Base
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


@app.on_event("shutdown")
async def stop_streams():
    """Cleanup on application shutdown"""
    logger.info("Application shutting down, cleaning up resources...")
    stream_manager.stop_all()
    
    # Stop video feed processor if it exists
    from routers.video_feed import processor, processor_lock, processor_thread
    with processor_lock:
        if processor is not None:
            logger.info("Stopping video feed processor...")
            try:
                processor.stop()
                # Wait for processor thread to finish (with timeout)
                if processor_thread and processor_thread.is_alive():
                    processor_thread.join(timeout=3.0)
                    if processor_thread.is_alive():
                        logger.warning("Processor thread did not stop gracefully")
            except Exception as e:
                logger.error(f"Error stopping processor: {e}")


